import getAudioDurationInSeconds from 'get-audio-duration';
import { read } from 'node-id3';
import * as fs from 'node:fs/promises';
import { z } from 'zod';
import { ASTRAY_FOLDER } from '../Constants';
import { EventBus } from '../events/bus/EventBus';
import { walkDir } from '../utils/walk';
import { Song, SongSchema } from './Song';

const disclaimer = 'This file is automatically generated by Astray. Do not edit it.' as const;

export const LibrarySchema = z.object({
	disclaimer: z.literal(disclaimer),
	songs: z.record(SongSchema),
});

export class Library {
	public songs = new Map<string, Song>();
	private CONFIG_PATH = `${ASTRAY_FOLDER}/indexed-library.json`;
	private SUPPORTED_FORMATS = ['mp3'];

	public constructor(private bus: EventBus) {}

	public async save() {
		console.log(`[Library] Saving library: ${this.CONFIG_PATH}`);

		const data = await LibrarySchema.parseAsync({
			disclaimer,
			songs: Object.fromEntries(this.songs),
		});

		await fs.writeFile(this.CONFIG_PATH, JSON.stringify(data, null, 2));
	}

	public async load() {
		const data = await fs.readFile(this.CONFIG_PATH, 'utf-8');
		const parsed = await LibrarySchema.parseAsync(JSON.parse(data));

		this.songs = new Map(Object.entries(parsed.songs).map(([key, value]) => [key, new Song(value, key)]));

		this.bus.emit('library:update', Array.from(this.songs.values()));
	}

	private async addSong(song: Song) {
		this.songs.set(song.id, song);
		this.bus.emit('library:update', Array.from(this.songs.values()));
		await this.save();
	}

	public async parseSong(path: string) {
		const tags = read(path);
		const duration = await this.getDuration(path);
		const id = this.generateId();
		const song = new Song(
			{
				title: tags.title || path.split('/').pop(),
				artist: tags.artist || 'Unknown Artist',
				album: tags.album || 'Unknown Album',
				duration: duration,
				path,
			},
			id,
		);
		await this.addSong(song);
		return song;
	}

	private async getDuration(path: string) {
		const dura = await getAudioDurationInSeconds(path);
		return dura;
	}

	public async parseFolder(path: string) {
		for await (const p of walkDir(path)) {
			if (this.SUPPORTED_FORMATS.includes(p.split('.').pop()!)) {
				console.log(`[Library] Parsing song ${p}`);
				try {
					await this.parseSong(p);
				} catch (e) {
					console.error(`[Library] Failed to parse song ${p}`);
					console.error(e);
				}
			}
		}
	}

	private generateId() {
		const future = Math.random().toString(36).slice(2);
		if (this.songs.has(future)) return this.generateId();
		return future;
	}
}
