import { deserializeSong, SerializedSong, Song } from '@astray/swrapper';
import { unpackage } from '@astray/swrapper-rn';
import * as FileSystem from 'expo-file-system';
import * as SecureStore from 'expo-secure-store';
import { z } from 'zod';

const disclaimer = 'This file is automatically generated by Astray. Do not edit it.' as const;

export const LibrarySchema = z.object({
	disclaimer: z.literal(disclaimer),
	songs: z.array(SerializedSong),
});

export class Library {
	public songs = new Map<string, Song>();

	public constructor() {}

	public async save() {
		console.log(`[Library] Saving library to SecureStore`);

		const data = await LibrarySchema.parseAsync({
			disclaimer,
			songs: Array.from(this.songs.values()).map((s) => s.serialize()),
		});

		await SecureStore.setItemAsync('library', JSON.stringify(data));
	}

	public async load() {
		const data = await SecureStore.getItemAsync('library');
		if (!data) return;

		const parsed = await LibrarySchema.parseAsync(JSON.parse(data));

		this.songs = new Map(parsed.songs.map((s) => [s.uniqueHash, deserializeSong(s)]));
	}

	private async addSong(song: Song) {
		this.songs.set(song.uniqueHash, song);
		await this.save();
	}

	public async parseSongPackage(spkg: ArrayBuffer) {
		try {
			const song = await unpackage(spkg);

			console.log(`Unpacked ${song.metadata.title}`, song.metadata);

			const fileUri = `${FileSystem.documentDirectory}${song.uniqueHash}.mp3`;

			await FileSystem.writeAsStringAsync(fileUri, song.buffer.toString('base64'), {
				encoding: FileSystem.EncodingType.Base64,
			});

			song.buffer = undefined;
			song.path = fileUri;

			await this.addSong(song);
		} catch (e) {
			console.error(e);
		}
	}
}
